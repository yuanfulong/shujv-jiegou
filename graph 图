//图是一种非线性的数据结构，不同于链表，栈，队列。和树一样非线性
但是和树不同的是，图可以以任何模式链接（树需要由根节点出发，连向这个根节点的子节点们，但是图没有任何限制，图内的一个节点可以随意连向其他节点）
图可以是空的图，即没储存任何的数据
构成一个图：
1.一些有限的（有确定个数）顶点（finite vertices）vertex顶点可以理解为node节点
2.一些有限的边缘（finite edge），这些边把各个顶点连接在一起，边可以带weight，就是边所带的信息，可以理解为一个点到另一个点的距离
图有有向directed graph和无向undirected graph之分
loop 一个顶点从他本身开始，并且连向它本身，中间没有经过任何点
cycle 一个顶点从他本身开始，最后也是连向它本身，但中间经过了别的点
multiple edges 多条边，两个顶点相连接，但是他俩之间有着多条边，不止一条
simple graph 一个图，没有loop也没有multiple edges（多条边），就叫简单图
//

//那么知道了图是什么之后，我们该怎么创建，实现一个图结构呢
我们可以用邻接矩阵来表示图内各个顶点的相连关系 
adjacency matrix 邻接矩阵
假设有三个顶点v0 v1 v2，v0分别和v1，v2相连
那么相连表现为true，不相连变现为 false的话，我们可以创立一个矩阵
graph[][],一共有三个顶点，那么就可以把他初始化为
graph[3][3]
因为这个矩阵里储存的是相连的关系，true和false，所以他的型是boolean
boolean graph[3][3] = {{F,T,T},{T,F,F},{T,F,F}}
也可以让他等于一个数字带代表edge带的信息
缺点是空间复杂度高，有很多空间被占用，是无用的
adjacency list邻接链表（解决了邻接矩阵会记录很多无用数据的缺点）
假设有n个顶点V0到Vn
那么我们创造一个数组，这个数组里储存的数据是（指向一个链表的指针）
那么很显然，如果用这个数组的下标0到n来表示顶点V0到Vn的话，每个下标里储存的这个链表自然就是他们之间的连接关系
例如下标0中储存了一个指针，这个指针指向了一个链表V1-》V4
那么就是说，顶点V0直接指向两个顶点，V1以及V4，
如果一个顶点V4并不直接指向任何一个节点（并不是说没有节点指向他自己），那么下标4里所存的就是null，不指向任何节点自然是空
比起邻接矩阵来说，链表里的节点自己就可以储存数据，因此不许要再多添加一个数组来存储每个顶点所带的值，更加的方便一些
即表示了连接的关系又表示了所带的数值
但是，缺点是没有办法表示两点之间的距离（edge））

如果想要遍历图内的数据的话（顶点所带的数值），我们有两种遍历方法
两种遍历方法内我们都需要记录下被访问过的节点
深度优先 与 广度优先
深度优先DFS depth first search
从根节点出发，一直到一条路的底，如果到底了就网上回溯看是否上一层的节点能够走一条新的路（有没有跟别的没被遍历的节点相连）
有的话，自然从那天没走过的路继续走，没有的话那么就需要继续回溯，直到根节点，然后如此反复，把整个图的所有没被访问的节点全部遍历

广度优先BFS breadth first search
根据和根节点的层级来访问，先访问最近的再向远处访问


