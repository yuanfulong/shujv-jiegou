//B树每个节点的定义
template <typename T,int M> //t代表数据元素类型。m代表树的阶
struct BTreeNode
{
    T data[M];
    BTreeNode<T,M> *childs[M+1];//子节点指针数组,一个名叫childs的大小为m+1的数组，里边的元素的类型都是储存BTreeNode型数据的指针
    BTreeNode<T;M> *parent;//父节点指针
    int size;//节点中的实际个数

    BTreeNode()
    {
        size = 0;
        for (int i = 0;i < M; ++i){
            data[i] = -1;//随便给一个值，方便观察
        }
        for (int i = 0;i < M + 1; ++i){
            childs[i] = nullptr;
        }
        parent = nullptr;

    }

}
template <typename T,int M> 
class BTree
{
    public:
    BTree()
    {
       root = nullptr; 
    }
    ~BTree(){
        ReleaseNode(root);
    }
    void InsertE(const T& e)//无法指定插入的位置，让程序内部自己定义
    {
        if (root == nullptr)
        {
            root = new BTreeNode <T, M>;
            root->data[0] = e;
            root->size = 1;
            return;//如果他是一个空的树，那么直接把这个e插到其data数组的第一个就行
        }
        //但是如果是一个非空的树,即其根节点已经被构造完成
        BTreeNode < T, M)* curnode = root;//新创建一个节点，当前节点，把root给这个当前节点
        BTreeNode < T, M)* parent = nullptr;
        while (curnode != nullptr)//判断curnode也就是root的非空的时候的各种情况
        {
            int i = 0;
            //找插入的位置
            while (i < curnode->size)//当curnode也就是root内有元素的时候，开始找插入的位置
            {
                if (curnode->data[i] == e)
                    return;//如果出现了要插入的e和当前b树内的数据相同，直接返回，不做插入

                if (curnode->data[i] < e)//当data内存在一个数要比e还小的时候，往后走，走到下个下标去，所以要++i
                    ++i;
                else
                    break;//直到这个else被实现，就是有一个data[i]要比想插入的数e大
                //那么break跳出循环，找到了要插入的位置i，因为要找的就是这个位置，这个刚刚好比e大的位置  
                //即便是所有的data[i]都没有比e大的，那么依旧可以进行最后一遍++i，这个i就是e插入的位置，因为这个时候e是最大的
                //既是把e插入在最右边，就是此时的++1之后的i
            }
            //新插入的数据总会落到最底层的叶子节点上，所以能往子树走就往子树继续前进
            parent = curnode;
            curnode = curnode->childs[i];//因为之前把oot赋值给了curnode，所以现在对curnode重新复制的话，给的是root节点内的childs数组的值，就是往下走了，走到了他i上的子节点上
            //上，找这个子节点上有没有一个 data【i】能比e大，重复这样往下走。直到到叶节点，如果赋值之后的curnode为空，也就是此时的root的childs【i】为空那么就是走到了叶节点上
            //因为如果一个节点是叶节点的话，节点内的childs数字内储存的指针节点们应该都是空
        }//这层while（curnode ！= nullptr）结束，也就是此时的curnode为空，已经落到了叶节点上，那么就进行在这个叶节点上进行插入的操作，也就是接下来的函数
        
        InsertDataIntoNode(curnode, e);
        //此时需要判单的是，在该阶段的数据数量是否在允许的范围内，一个四阶b树最多有三个数据，达到了四个就必须要拆分了
    }
    //向当前节点插入数据
    int InsertDataIntoNode(BTreeNode<T, M>* curnode, const T& e) {
        int i;
        for (i = curnode->size - 1;i >= 0;--i)//从size = 1到0的循环，倒着，遍寻data数组
        {
            if (i = curnode->data[i] > e)//如果存在一个数要比e大
            {
                curnode->data[i + 1] = curnode->data[i];//那么把这个数放到他的下一个下标上去
            }
            else
            {
                break;
            }
        }
        curnode->childs[i + 1] = e;
        curnode->size++;
        return (i + 1);
    }
    private:
    BTreeNode<T,M>* root;//树根指针
    void ReleaseNode(BTreeNode<T,M>* pnode)
    {
        if(pnode != nullptr)
        {
            for(int i = 0;i < (pnode->size + 1); ++i)
            {
                if(pnode->childs[i] != nullptr)
                {
                    ReleaseNode(pnode->childs[i]);
                }
            }
        }
        delete pnode;
    }
}



